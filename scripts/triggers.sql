--criar trigger que faça a mesma coisa que a proc 
--SP_INSERT_EXCEDEED_CALORIES

CREATE OR REPLACE TRIGGER TR_INSERT_EXCEDEED_CALORIES
AFTER INSERT ON TB_DAILY_CALORIES
REFERENCING NEW AS NOVO OLD AS VELHO
FOR EACH ROW
DECLARE 
V_RQT_CALORIES_GOAL NUMBER(12,0);
V_QT_CALORIES_EXCEDEED NUMBER(12,0) := 0;
V_MONTH_REGISTER VARCHAR2(10);
BEGIN
	V_MONTH_REGISTER := SF_RETURN_MONTH(:NOVO.DT_REGISTER);
	SELECT TG.QT_CALORIES_GOAL
	INTO V_RQT_CALORIES_GOAL
	FROM TB_MONTH_CALORIES_GOAL TG
	WHERE TG.DS_MONTH = V_MONTH_REGISTER;
	
	CASE WHEN :NOVO.QT_CALORIES > V_RQT_CALORIES_GOAL 
	THEN 
		V_QT_CALORIES_EXCEDEED := :NOVO.QT_CALORIES - V_RQT_CALORIES_GOAL;
		INSERT INTO TB_DAILY_CALORIES_EXCEDEED
		(CD_DAILY_CAL_EXCEDEED, DT_REGISTER, QT_CALORIES)
		VALUES(SQ_CD_DAILY_CAL.nextval, :NOVO.DT_REGISTER, V_QT_CALORIES_EXCEDEED);
	ELSE
		NULL;
	END CASE;	
END;

--quando o rollback acontece para a ação DML que dispara o trigger
--o trigger não executado, pois o trigger é chamado na mesma transação
--do isert
DECLARE
V_TESTE_CAL NUMBER(12, 0);
BEGIN 
	V_TESTE_CAL := 5000;

	INSERT INTO TB_DAILY_CALORIES
	(CD_DAILY_CAL, DT_REGISTER, QT_CALORIES)
	VALUES(SQ_CD_DAILY_CAL.NEXTVAL, TRUNC(SYSDATE), 2500);
	
	IF V_TESTE_CAL > 3000
	THEN ROLLBACK;
	END IF;
END;
